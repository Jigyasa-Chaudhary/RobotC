
#pragma config(Sensor, in2,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  button,         sensorTouch)
#pragma config(Sensor, dgtl5,  limitLeft,      sensorTouch)
#pragma config(Sensor, dgtl6,  limitRight,     sensorTouch)
#pragma config(Sensor, dgtl11, RedLED1,        sensorDigitalOut)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port4,           claw1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* ROBOTC code for group G008, lab B09
*/

#define EXERCISE_NUMBER  3

// The minimum IR sensor value that the robot picks up to approach
const int minlightthreshold = 200;
const   int OFF = 0;
const   int ON  = 1;
//flag to store button1 input
bool button_pushed;

// declaring the function so that it can be called in a function defined after its own declaration
void exercise_3();

enum T_exercise3_state {
  MOTOR_STOP,
  MOTOR_RUNNING,
  MOTOR_TURNING,
  };

// the exercise state variable, made global as it is called in multiple functions
T_exercise3_state exercise3_state;

/*
   cable() makes the robot approach the beacon and flags the success of the mission
   by turning the red LED on
*/
 void cable(){
				motor[motor1] = 0;
    		motor[motor2] = 0;
    		delay(600);
    		motor[claw1]=20;
    		motor[claw2]=-20;
    		delay(2000);
    		SensorValue[RedLED1]=ON;
    		motor[motor1] = -50;
   			motor[motor2] = 45;
  		  sleep(1500);
  		  motor[motor1] = -30;
   			motor[motor2] = -25;
  		  sleep(300);
}
 /*
   this function makes the robot avoid walls using the values from limit switches
 */
void avoidwalls() {

/* if the robot hits a wall on the right;
 * the robot stops, moves back and then turns to the left
*/
   if (SensorValue[limitRight]){
    	  motor[motor1] = 0;
    	  motor[motor2] = 0;
    	  sleep(200);
    	  motor[motor1] = -30;
    	  motor[motor2] = 25;
    	  sleep(200);
    	  motor[motor1] = -30;
    	  motor[motor2] = -25;
    	  delay(1000);
   }

/*
 * if the robot hits a wall on the left;
 * the robot stops, moves back and then turns to the right
*/
   if (SensorValue[limitLeft]){
    	  motor[motor1] = 0;
    	  motor[motor2] = 0;
    	  sleep(200);
    	  motor[motor1] = -30;
    	  motor[motor2] = 25;
    	  sleep(200);
    	  motor[motor1] = 30;
    	  motor[motor2] = 25;
    	  delay(1000);
   }

/*
 * if there is a wall or an object too close in front of the ultrasonic sensor
 * the robot stops, and backs
*/
   if (SensorValue[sonarSensor] < 22){
    	  motor[motor1] = 0;
    	  motor[motor2] = 0;
    	  sleep(200);
    	  motor[motor1] = -30;
    	  motor[motor2] = 25;
    	  sleep(200);
    	 	motor[motor1] = -30;
    	  motor[motor2] = -25;
    	  sleep(1000);

     SensorValue[RedLED1] = OFF;
      button_pushed=false;
      exercise3_state = MOTOR_STOP;

 }
}

/*
 * this function searches for the beacon by comparing
 * the value recorded by the phototransistor to the minimum threshold
*/
void searchbeacon() {
	int max = SensorValue[IRsensor1];
   motor[motor1] = 25;
   motor[motor2] = 25;
   delay(200);
   if (max>minlightthreshold){
    	motor[motor1] = 35;
     	motor[motor2] = -35;
     	sleep(1000);
    	while (max>minlightthreshold){
    		/*
    		 * the case when the robot is in front of the beacon
    		*/
    	if(SensorValue[sonarSensor]<17 && SensorValue(IRsensor1) > 3000){
    		cable();
    		}
    	if(SensorValue(IRsensor1)>max+400){
    			max=SensorValue(IRsensor1);
    				motor[motor1] = 0;
    				motor[motor2] = 0;
  		 			sleep(500);
    				motor[motor1] = 35;
     				motor[motor2] = -35;
     				sleep(1000);
    		}
    	if(SensorValue(IRsensor1)<max )	{
    			avoidwalls();
    			searchbeacon();
    		}
    	}
    }
 }



// the start of the program and the start of the searching as the button is pushed
void monitorInput()
{
 if(SensorValue(button) && !button_pushed)
 {
  button_pushed = true;
 }
}

void exercise_3(){
  SensorValue(RedLED1)= OFF;
 exercise3_state = MOTOR_STOP;
 while(true){
  monitorInput();
  switch(exercise3_state) {

  case MOTOR_STOP:

  SensorValue(RedLED1)= OFF;
   if ( button_pushed ) {
    exercise3_state = MOTOR_RUNNING;
    }
   break;

  case MOTOR_RUNNING:
  SensorValue(RedLED1)= OFF;

  while (true){
  	avoidwalls();
		searchbeacon();
  	}
   default:
}
}
}
task main()
{
  SensorValue(RedLED1)= OFF;
	button_pushed  = false;
 switch (EXERCISE_NUMBER)
 {

 case 3:
  exercise_3();
  break;
 default: //should never get here.
 } // end switch
}